const { GoogleGenAI } = require("@google/genai");
const { Readable } = require('stream');

class GeminiClient {
  constructor(apiKey, options = {}) {
    if (!apiKey) {
      throw new Error("API key is required");
    }
    this.genAI = new GoogleGenAI({ apiKey: apiKey });
    this.options = options;
  }

  async generateText(prompt) {
    console.log("Generating text with prompt:", prompt);

    const response = await this.genAI.models.generateContent({
      model: "gemini-2.5-flash-lite",
      contents: prompt
    });
    return response.text;
  }

  /**
   * Generates text from a multimodal prompt (text + image).
   * @param {string} textPrompt The text prompt to send.
   * @param {Buffer} imageBuffer The image as a Buffer.
   * @param {string} mimeType The MIME type of the image (e.g., 'image/jpeg', 'image/png').
   * @returns {Promise<string>} The generated text response.
   */
  async generateTextWithImage(textPrompt, imageBuffer, mimeType = 'image/jpeg') {
    console.log("Generating text with image, prompt:", textPrompt);
    console.log("Image buffer size:", imageBuffer.length, "bytes, mimeType:", mimeType);

    // Convert Buffer to Base64
    const base64Image = imageBuffer.toString('base64');

    // Build multimodal content array
    // Tip from Gemini docs: place text prompt after the image for best results with single image
    const contents = [
      {
        inlineData: {
          mimeType: mimeType,
          data: base64Image,
        },
      },
      textPrompt,
    ];

    const response = await this.genAI.models.generateContent({
      model: "gemini-2.5-flash-lite",
      contents: contents,
    });

    return response.text;
  }

  /**
   * Helper to convert a readable stream to a Buffer.
   * @param {import('stream').Readable} stream The readable stream.
   * @returns {Promise<Buffer>} The buffer containing the stream data.
   */
  static async streamToBuffer(stream) {
    const chunks = [];
    return new Promise((resolve, reject) => {
      stream.on('data', (chunk) => chunks.push(chunk));
      stream.on('end', () => resolve(Buffer.concat(chunks)));
      stream.on('error', (err) => reject(err));
    });
  }

  /**
  * @param {string} prompt The description of the image to generate.
  * @returns {string} The Base64 string of the generated image (the token).
  */
  async generateImage(prompt) {
    console.log("Generating image with Gemini (text-to-image) for prompt:", prompt);

    try {
      console.log("Calling Gemini image generation API...");
      
      // Use gemini-2.5-flash-image for text-to-image generation (requires paid tier)
      const response = await this.genAI.models.generateContent({
        model: "gemini-2.5-flash-image",
        contents: prompt,
      });

      console.log("Gemini API response received");

      // Extract the image from the response
      // The response contains parts which can be text or inlineData (images)
      if (!response.candidates || response.candidates.length === 0) {
        throw new Error("No candidates in Gemini response");
      }

      const parts = response.candidates[0].content.parts;
      
      // Find the image part (inlineData)
      const imagePart = parts.find(part => part.inlineData);
      
      if (!imagePart) {
        throw new Error("No image generated by Gemini");
      }

      const base64ImageBytes = imagePart.inlineData.data;

      if (!base64ImageBytes) {
        throw new Error("No image data in response");
      }

      console.log("Image generated successfully, bytes length:", base64ImageBytes.length);

      // Return the Base64 string
      return base64ImageBytes;
    } catch (error) {
      console.error("Error generating image with Gemini:", error);
      throw error;
    }
  }

  /**
  * Generates an image and returns it as a Readable stream.
  * @param {string} prompt The description of the image to generate.
  * @returns {Promise<Readable>} A Readable stream of the generated image.
  */
  async generateImageStream(prompt) {
    console.log("generateImageStream called");
    const base64Image = await this.generateImage(prompt);
    console.log("Converting base64 to buffer...");
    const imageBuffer = Buffer.from(base64Image, 'base64');
    console.log("Buffer created, size:", imageBuffer.length, "bytes");
    const stream = Readable.from(imageBuffer);
    console.log("Stream created");
    return stream;
  }

}

module.exports = { GeminiClient };
